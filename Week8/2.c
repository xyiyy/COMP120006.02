#include <stdio.h>

// F[n] = ansA[0][0], ansA = A * X^(n-2)
// 当然这是对于如果取得值是ansA[0][0]而言的，代码主要是针对这个写的，大家可以根据以下建议修改看看
// 如果取得值是F[n]=ansA[1][1]的话，则ansA = A * X^(n)
// 当然仔细观察，还可以发现初始的A矩阵其实就等于X矩阵

int main(){
    int A[2][2] = {{1, 1}, {1, 0}};
    int X[2][2] = {{1, 1}, {1, 0}};
    int n, i, j, k, p = 10007;
    scanf("%d", &n);
    if(n == 0){
        printf("0\n");
    }else if(n == 1){
        printf("1\n");
    }else{
        n = n - 2;
        int temp[2][2];
        // 用来存取矩阵乘法的中间变量
        // 因为比如在算新的A[0][0]的时候，要用到旧的A[0][0],A[0][1]
        // 而在算新的A[0][1]的时候，还会要用到旧的A[0][0],A[0][1]，
        // 所以前面算出A[0][0]的时候不能直接去更新数组中的A[0][0]，而是要先存下来
        while(n > 0){
            if(n % 2 == 1){
                // A = A * X % p
                for(i = 0; i < 2; i ++){
                    for(j = 0; j < 2; j ++){
                        temp[i][j] = 0;//数组要初始化为0，务必记住，而且是在每次使用前要先初始化
                        for(k = 0; k < 2; k ++){
                            temp[i][j] = (temp[i][j] + (A[i][k] * X[k][j]) % p) % p;
                        }//这个循环是用来计算新的A[i][j]的
                        // temp[i][j] = sigma k (A[i][k]*X[k][j])，
                        // 即第i行乘上第j列的乘积的和
                    }
                }
                for(i = 0; i < 2; i ++){// 将上面算出来新的A矩阵赋值给A
                    for(j = 0; j < 2; j ++){
                        A[i][j] = temp[i][j];
                    }
                }
            }
            // X = X * X
            // 以下两块和上面的道理一致
            for(i = 0; i < 2; i ++){
                for(j = 0; j < 2; j ++){
                    temp[i][j] = 0;
                    for(k = 0; k < 2; k ++){
                        temp[i][j] = (temp[i][j] + (X[i][k] * X[k][j]) % p) % p;
                    }
                }
            }
            for(i = 0; i < 2; i ++){
                for(j = 0; j < 2; j ++){
                    X[i][j] = temp[i][j];
                }
            }
            n = n / 2;
        }
        printf("%d\n",A[0][0]);//输出最终的答案
    }
    return 0;
}
